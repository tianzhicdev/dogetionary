in the onboarding journey, if user is studying english, we add one more question
"are you studying for " menu with TOEFL/IELTS/NONE

we recommend the user to register but users can skip
if user select an active test, we should generate a schedule and display progress
"prepare for my test" on landing -> "practice"
display definition for new word in practice; perhaps with some special effects
"review" -> "practice"



let's design a teacher's portal
1. students can add an id in settings to join a group
2. teachers can access a web app /teacher-admin to view students stats
in /teacher-admin
we should all the groups
when click into a group, we show all the students and their stats
such as total saved words, total review count, 
when click into a student, we can see more details such as 
1. number of words saved in the last 7 days (show count for each day)
2. number of words reviewed in the last 7 days (show count for each day)
3. most recent saved 10 words 
4. more recent reviedwed 10 words


we need to think about gamified app wholistically. 
target users: highly motivated individuals who want to take tests/ build vocabulary for work/ 
what is the best way to learn a language? 1. repetition and  2.use
strategically, we should make an app that focus on building vocabulary.
"<APP NAME>: vocabulary for ielts"

1. onboarding

optional: 
ask intention, nickname, age
registration

english level tests

essential:
ask days/commitment time;


2. Sections:

essential:

a. Progress & Lookup

c. Schedule

d. Settings

optional
e. leaderboard


tasks:

1. create landing page that shows progress and lookup option

2. generate schedule

assume X words need to be learned;
every day we add Y new words to be learned;

for each new word, we assume that they need to practiced at Z0, Z1, Z2... days;
get_schedule(past_schedule: [(datetime, true/false), (datetime, true/false)]): future_schedule [(datetime, true/false), (datetime, true/false)]
# this func should use existing get_next_review_date_new to calc 7 future review dates assuming that the user always get it right when reviewing the word in the future 

initiate_schedule(test_name, study_duration): {date: {new_words: [], practice: []}... date2:{} ... }
# here daily new words = (test total words)/study_duration
# we should exclude words that are not new from being added as new (exclude words from saved_words table)
# but the non-new words that are part of the test vocabulary should be added the schedule as practice words;

we need a database strucuture to store the schedule; 
we should be able to call initiate_schedule every day (or any time really) to refresh the schedule so we always take into account new events from the user, such as study_duration change, reviewed words that are supposed to be reviewed in the future (so the next review time should be delayed);
multi selections 

1. the LLM calls need to be faster

3. words search in saved words.
3.1 let's define the word progress bar number logic: if a word most recent reivew count >= 7 times with no error in the past 84 dqys, it is 7. >= 6 times in the past 41 days, return 6;  >= 5 times in the past 22 days, return 5;   >= 4 times in the past 12 days, return 4;   >= 3 times in the past 6 days, return 3;   >= 5 times in the past 41 days, return 6;   >= 2 times in the past 3 days, return 2;  >= 1 times, return 1
5. remove recogition in practice mode, if user select wrong, we should show what is correct. regardless if user select right or wrong, we should show a pop-up window with the showing the definition view of the word, with a "next" button at the buttom to practice the next word 
4.1 practice naming

2. when it is done, show badges for when 5, 10, 50, 100, 200.... ALL words learnt;
https://www.figma.com/design/NzE6vNDdbpeafseWzGR71c/Badges-and-Awards--Community-?node-id=0-1&p=f&t=Go42SXoQ8mz88bwB-0

we should add a AchievementView where we show some badges according to the number of saved words
10 words 
30 words 
50 words 
100 words 
150 words 
200 words 
250 words 
300 words 
350 words 
400 words 
450 words 
500 words -> award 
600 words
700 words
... 
1000 words -> big award 
1500 -> bigger award
2000 -> biggest award

we should use sf symbols to keep it simple
AchievementView should be displayed on the top of the dictionary tab
please design first

1.1 onboarding should show the schedule.
1. progress bar, when it opens, show show more meaningful stats. 
1. strike, badges

4. practice mode

1. badge system

let's change how the badge system work; we move from saved_words based to number of reviews based; do not change the icons and everything. make the number to get the badge to be 10x the current number; (because reviews are easier)
let's call it score (score = number of reviews where failed review = 1, success review = 2) 
it it should be displayed on the top of practice mode always, every time user completes a review, we should add to the score, making a little animition when the score changes;
the score does not have to sync back to the db, becuase it can always get calculated from reviews; we only need to sync from backend when user lands on a page where the score needs to be displayed;
let's design first, mention updates in backend/ui and db (if any);


2. practice mode interface 
in the practice tab; lets redefign the UI:
we allow users to refresh to get today's schedule:
it should know the number of new words, the number of due words; and number of words that have not been reivewed in the past 24 hours, and score;
perhaps we need a /v3/practice-status 

on the top we should show a status bar: we display only # new words, # of due words and score;
if  # new words, # of due words  are both 0; in the status bar we also display "Congrats! Today's learning practice is complete!" 

if # new words, # of due words # of words that have not been reivewed in the past 24 hours are all 0; 
we show "You've done so well, there is nothing to practice!"

if any of the above is not 0, we just call /v3/next-review-word-with-new-words which automatically prioritize new words > due words > other words that have not ben reviewed in the past 24H;

in other words, when user switch to practice tab, if there is something to practice, he see the question right away, not needing to click "start" button;
when there is not anything to practice, he sees "You've done so well, there is nothing to practice!"
let's design this first;


performance: 
it is quite slow for loading the next question; let's do the following
create endpint v3/next-review-word-with-new-words/<count>
when user first come to practice mode, we should load just 3 questions;
but on the backgroud we should make sure that we have at least 10 questions in a queue;
when a user answers one question, we should refill the queue in ios mem so that we always have 10 questions (or less if user do not have more than 10 to practice anyway);
the in mem queue should be unique and ordered 
we should show the queue in real time on the screen in debug mode;
let's discuss first: how do we ensure order and dedupe? (if we have 3 in the in mem queue and we ask backend for 10 more, likely the 3 in mem are returned too);

a. schedule should be made deterministically with deterministic order b.in practice mode, practicable words are basically words scheduled for today and words that are not due but not have been reviewed in the past 24h, we should call it "not-due-yet" words;
b. to keep the logic simple, v3/next-review-words-batch should be today's words from schedule + "not-due-yet" words;

2. animation for badge

in leaderboard mode, we should use score instead of practice count; let's create a new endpoint for this so older version of the app can still work;


2.1 in the saved words list view, we should 1. make the list more compact, we should try to fix the word itself and the review counts on the same row, only overflow to the second row if the word is too long;
2.the 7 blocks bar is kind ugly, can we user something better to indicate the progress?

7. reminder time set
we now always remind users at 11:59am;
we should let user choose in the setting -- display the timezone but do not let users change it; timezone should be from the system reading;

4. demo test
we want to use 20 words or so and call it demo test for testing purposesl it should be the same as toefl or ielts but just called demo with 20 words, some of the them overlap with toefl or ielts;


bugs:
1.lsit view I/T icon;

4. some questions pronunciations are erroneous, we need a reporting/fixing mechanism;
5. review word count should include new words.  

5. slider for days selection

2. force an upgrade;


1. debug mode
let's add a debug mode where uses can enable it; currently the debug mode is using '#if DEBUG' macro, we should change it to use this configurable value;
4. settings only show tests that are avaialble for the learning lang;
8. operation monitoring
2. errors must be logged in a separate file and easily; this log must be easily visible - design a way to read the logs easily with current setup using docker 
3. graph count and perf of every v3 call using promeseus; especially LLM calls -- how to setup promeseus and instrument the code easily?


10. tooltip for known words
dont practice this word in practice mode

3. toefl ielts words
we have 
resources/ielts-4323-annotated.csv
and 
resources/toefl-4889-annotated.csv

each word has a test and a level

now we have all tests to be toefl and ielts 
in the database we have is_toefl and is_ielts
we should change it to 
is_toefl_beginner
is_toefl_intermidiate
is_toefl (the same as is_toefl_advanced)
same goes to ielts

changes should be reflected in onboarding journey, scheduling and settings too;
let's investigate what changes need to be made, including ios/backend and db

scripts/import_test_vocabularies.py

bf: current question problem


toggle bug

when test prep settings change, lots of ui components should refresh according to the schedule; (could be race condition)



9. badge for finishing
we need a badge/award for when users finish their test -- when all the words from the test vocab are saved words; 
it should look and feel the same from the frontend perspective as other badges;
write some review data so i can just practice a few words to see the award being acheived;

1. we only display badges that are earned, we dont have to show greyed out badges
2. there should be no difference between award and badge;
3. there are 2 types of badges one that is based on score, one that is based on whether the user finishes a test prep;
4. get_test_vocabulary_awards should be kept simple that return 
{
"test_name":{

    saved_test_words: 20,
    totol_test_words:2000,
}
...
}  
for all the tests regardless if the user has any test enabled -- we should display his past badges too.
this should be sufficient for the UI to determine if the user earned test related badges.

we should always display the progress bar, if the user has no test prep enabled, we display the progress toward the next score based badge; 


6. changing schedule affect streak
when user change the number of days for a test to change to another test, we should remind the user that if he change the test, he loses streaks

8. tooltip

Building vocabulary the old way is wasteful—you forget, re-learn, forget again. Fledge fixes this. It tracks every word you study, calculates when you're about to forget, and prompts you at exactly the right moment. This is SuperMemo spaced repetition, and it can make your learning up to 20x more efficient. For every 1,000 words, that's 80+ hours of your life back.
Fledge manages your vocabulary building algorithmatically; fron your practice history, it calculates the best timing to reinforce your memory and prompts you to practice at the BEST timing to practice; this is the most effective method of building a vocabulary; using this method, you can achieve 20x of the efficiency;   

1. forced upgrade
1. LLM calls by type and duration
operationally:
2. user actions and action logs by user;

rolling log - searchable log

1. dumb down the words in the questions
2. more types of questions that help memorize the words

in the definition card, let's try to keep things more compact: 
1. move the picture to the upper right of the corner and make it smaller (it should still be clickable as it is now)
2. do not use collapseable components, just show the content;

in the search tab, when a definition is displayed, we should hide the search/words toggle and the progress bar, they took too much of the screen;
3. definitions need to help memorize too

show only one quote;
days configurable;

quote

bug:

1. due soon should not be adding practice button or badge
2. practice should be test practice or other practice words



saved button removed


pronunciation practice done;
picture view;

spin;
app logo;

declaration;

branding, header size
remove tianz;

move to server;
use a new domain;

1. font too small;
2. swipe difficult
3. graph theme not done
4. system color affects wheel text color
5. badge should not include due soon; 
1. videos multi select theme: it should be almost identical to other multi secletion themes; 

it should look like
video
transcript; (highlight the word)
what is the meaning of "word"? 
A
B
C
D

UI 


3. prepopulate all the test words








2.Pipeline: 
some of the videos do not actually contain the word; lets do a clean up, remove word_to_video records where the transcript does not actually contain the word;
2. more video - high quality


3. prepopulate all the test words
zh done
spanish and others next

4. more test prep categories


3. cloudflare cache;



swipe button no animation;


-- 

bugfix: 
user timezone;
streak calculation;

vocab:

1. word list
2. more types

1. merge multi choice questions
3. video queue 

1. questions: some times all the choices are valid;
2. no difficult words in the question;
we need to monitor this prorcess;


answered, not moving;


1. change back to groq but use chatgpt to prepopulate



UI: 
4. swipe up

movie name;

2. dictionary card for all words

refactoring:
5. backend code refactor


notification and cache clear

backend code remove redundant

demo test

-- done --




schedule and practice status logic is too complicated, need a human review;


UI menu button 
badge png
learning english only, chinese/spanish/...
names
snapshot






pipeline + human verification;
  i need to build an automatic video download/upload pipeline; I
  think this is the plan:
  1. we query an endpoint to get 1 word that is in test_vocabularies
  (it will be renamed to bundle_vocabularies) and has no video
  associated with it in word_To_video
  2. we query clip.cafe to get some videos (search criteria: popular
  movie scene, contains procisely this word) hopefully we get 10+
  videos metadata; here we do not download videos yet;
  3. we send those metadata (we can batch multiple) to ask LLM to
  score each video based 2 criteria (does this video illustrate the
  meaning of the word well? does the video kinda independent and
  provide sufficient context for audience to understand the
  situation);
  4. then we rank the results and set 0.6 for education and 0.6 (the
  threshold should be easily configureable);
  5. then we download the videos
  6. generate mp3 and then audio transcripts in metadata_v3.json for
  those videos (reference existing script to see what v3 does -- at
  least it should have movie_title, movie_year, linked words,
  audio_transcripts and others)
  6. then we upload the videos and word_to_video using existing
  backend endpoints

  requirements: end result is a video_pipeline.sh --backend
  https://kwafy.com/api (or localhost:5001) --staging_dir
  /Volumns/databank/shortfilms (in fact we should use this dir to
  stage videos)

  let's do some planning given this is a big task, there are lots of
  scripts ready in scripts dir for reference;

  videos/mp3/metadata_v3 creation should be idenpotent, meaning if
  they are present we should not make them again;

  do you have more questions? let's do a research on how this can be
  done;






















producitonize:

branding

grafana -- finetune, perhaps expose to the internet


1. populate words;
2. background open ai fixer
3. test a few days
4. 

ads:

这个App不会对你手软。托福/雅思词汇 30天搞定
不惯着你的背词App

What if hard work was the shortcut?
The hard way is the fast way.
"What if easy apps are holding you back?"

sound?





--- future --- 


queue returned response not in order; -- prob ok
6. word family problem
no word specific lang;
we should only support one type of learning lange and native language 

if user change learning lange, saved words and schedule should be cleared; 

perhaps not good for new words 

1. ask user to pronounce a sentence or phrase with that word in it (we already have the capability to generate sound and verify user pronunciation, we should reuse exiting components as much as possible)
2. spell the word with hints (fill some characters) apple -> a__le
3. describe a situation and ask users to pick an appropriate word -> multi choice 
"Your friend's cooking is terrible. Which word do you use?" (interesting / disgusting / unique)
"Which is MORE extreme?" (dislike / loathe)
Complete the Analogy -> multi choice -> multi choice "Happy : Ecstatic :: Sad : ____" (devastated / blue / meh)


not all questions can use below format, need to categorize words


3. which of the following word is a synonym -> multi choice
4. which of the following word is an antonym -> multi choice
5. describe a situation and ask users to pick an appropriate word -> multi choice 
"Your friend's cooking is terrible. Which word do you use?" (interesting / disgusting / unique)
"Which is MORE extreme?" (dislike / loathe)
Complete the Analogy -> multi choice -> multi choice "Happy : Ecstatic :: Sad : ____" (devastated / blue / meh)




--- refactoring --
  Executive Summary: Code Quality Analysis

  The Three Functions You Asked About

  1. get_review_words_batch() - handlers/review_batch.py (381
  lines!)

  Status: EXTREMELY COMPLEX ❌

  What it does:
  - Fetches user timezone → calculates today's schedule → fetches
  4 types of words → generates questions → generates audio →
  returns batch

  Major problems:
  - 381 lines (should be <100)
  - Duplicates schedule calculation (50+ lines identical to
  practice_status.py and schedule.py)
  - 8+ database queries
  - Mixed concerns: HTTP handling + business logic + data access
  all in one function

  2. get_practice_status() - handlers/practice_status.py (173
  lines)

  Status: VERY COMPLEX ❌

  What it does:
  - Gets words reviewed today → calculates schedule → counts
  new/practice/due words → calculates user score

  Major problems:
  - Duplicates 50+ lines of schedule calculation (identical to
  review_batch and schedule)
  - Duplicates timezone fetching (8 locations total)
  - Duplicates "words reviewed today" query (3 locations total)

  3. calc_schedule() - services/schedule_service.py (236 lines)

  Status: EXTREMELY COMPLEX ❌

  What it does:
  - Categorizes words → calculates new word quota → builds
  practice schedule for all days → projects future reviews

  Major problems:
  - 236 lines (should be split into 5-6 smaller functions)
  - 7 parameters (should use config object)
  - Deep nesting (5 levels)
  - No extractable helpers despite clear sub-tasks

  ---
  CRITICAL FINDING: Massive Code Duplication

  The Smoking Gun: ~150 Lines Duplicated 3 Times

  All three functions have IDENTICAL schedule calculation logic:

  # This EXACT code appears in 3 places:
  # 1. review_batch.py lines 166-206 (40 lines)
  # 2. practice_status.py lines 99-155 (56 lines)
  # 3. schedule.py lines 110-193 (83 lines)

  # Fetch user preferences
  cur.execute("""SELECT toefl_beginner_enabled, ... FROM
  user_preferences ...""")
  prefs = cur.fetchone()

  # Check test prep enabled (11-way OR)
  test_prep_enabled = (prefs.get('toefl_enabled') or
  prefs.get('ielts_enabled') or ...)

  # Get active test type
  test_type = get_active_test_type(prefs)

  # Validate target_end_date
  if test_type and target_end_date and target_end_date > today:
      # Calculate full schedule
      schedule_data = fetch_schedule_data(user_id, test_type,
  user_tz, today)
      schedule_result = calc_schedule(...)
      today_entry =
  schedule_result['daily_schedules'].get(today_key)

  Impact: ~150 lines of duplicated code across 3 critical
  functions!

  ---
  Common Functions We Can Extract (HIGH PRIORITY)

  1. get_today_schedule_entry(user_id, user_tz, today)

  Replaces: 150 lines duplicated 3 timesReturns: Today's schedule
  entry or NoneUsed by: review_batch, practice_status, schedule
  handlersCode reduction: 90%

  2. get_user_today(user_id)

  Replaces: 16 lines duplicated 8 timesReturns: (user_tz,
  today_date)Used by: All schedule-related functionsCode
  reduction: 50%

  3. is_test_prep_enabled(prefs)

  Replaces: 27 lines duplicated 3 timesReturns: BooleanUsed by:
  Schedule validation in 3 handlersCode reduction: 89%

  4. get_user_schedule_preferences(user_id)

  Replaces: Query duplicated 5+ timesReturns: User prefs dict with
   test settingsUsed by: All schedule handlersCode reduction: 75%

  5. Already exists but unused: get_words_reviewed_on_date()

  Location: schedule_service.py:411-438Currently duplicated in:
  review_batch.py:149-156, practice_status.py:68-75Action needed:
  Use existing function instead of duplicating queryCode
  reduction: 20 lines eliminated

  ---
  Other Critical Code Quality Issues Found

  God Functions (>200 lines each)

  | Function                  | Lines | Should Be
                  |
  |---------------------------|-------|---------------------------
  ----------------|
  | get_review_words_batch()  | 381   | Split into 4-5 functions
  (~80 lines each) |
  | calc_schedule()           | 236   | Split into 3-4 functions
  (~60 lines each) |
  | get_today_schedule()      | 215   | Split into 3 functions
                  |
  | get_schedule_range()      | 220   | Split into 3 functions
                  |
  | generate_html_dashboard() | ~200  | Split into 5-6 functions
                  |

  Long Parameter Lists

  - calc_schedule(): 7 parameters → Should use config object
  - generate_html_dashboard(): 12 parameters! → Should use
  dataclass

  Tight Coupling (Handlers importing handlers)

  # handlers/schedule.py imports:
  from handlers.bundle_vocabulary import get_active_test_type  ❌
  from handlers.streaks import calculate_streak_days  ❌

  # handlers/practice_status.py imports:
  from handlers.achievements import calculate_user_score  ❌

  # handlers/review_batch.py imports:
  from handlers.words import generate_audio_for_text  ❌

  Problem: Violates layered architecture, creates circular
  dependency risk

  Solution: Move shared logic to services layer

  Database Connection Leaks Risk

  Found 40+ instances of manual connection management without
  proper try/finally blocks

  Magic Numbers

  count = min(max(count, 1), 20)  # Why 20?
  for i in range(7):  # Why 7?
  INTERVAL '24 hours'  # Appears 5+ times

  ---
  Proposed Refactoring Strategy

  Phase 1: Extract Common Functions (2-3 days)

  Priority 1: Extract schedule calculation duplication
  - Create get_today_schedule_entry()
  - Update review_batch.py, practice_status.py, schedule.py to use
   it
  - Impact: 150 lines → 3 function calls

  Priority 2: Extract common data fetching
  - Create get_user_today()
  - Create is_test_prep_enabled()
  - Use existing get_words_reviewed_on_date()
  - Impact: ~90 lines eliminated

  Priority 3: Extract user preferences query
  - Create get_user_schedule_preferences()
  - Impact: ~40 lines eliminated

  Total Phase 1 impact: ~280 lines eliminated, much clearer code

  ---
  Phase 2: Break Down God Functions (3-4 days)

  get_review_words_batch() → 5 functions:
  1. fetch_review_batch_prerequisites() - Get timezone, reviewed
  words, schedule
  2. fetch_new_words_batch() - Get new words from schedule
  3. fetch_practice_words_batch() - Get test + non-test practice
  4. fetch_not_due_words_batch() - Get not-due-yet words
  5. enrich_words_with_questions_and_audio() - Generate
  questions/audio

  calc_schedule() → 4 functions:
  1. categorize_saved_words() - Split test/non-test
  2. calculate_new_words_quota() - Daily new word allocation
  3. build_practice_schedule() - Generate due dates for reviews
  4. project_future_reviews() - Calculate 7-day projection

  Total Phase 2 impact: 600 lines → 15 focused functions (40 lines
   each)

  ---
  Phase 3: Fix Architecture (2-3 days)

  Move business logic to services:
  handlers/           (HTTP only - request/response)
    ├─ review_batch.py       → calls ReviewBatchService
    ├─ practice_status.py    → calls PracticeStatusService
    └─ schedule.py           → calls ScheduleService

  services/           (Business logic - no HTTP)
    ├─ review_batch_service.py
    ├─ practice_status_service.py
    ├─ schedule_service.py    (already exists, improve it)
    └─ audio_service.py       (NEW - move from handlers/words.py)

  repositories/       (Data access - NEW layer)
    ├─ schedule_repository.py
    └─ review_repository.py

  Benefits:
  - ✅ Testable business logic
  - ✅ No handler-to-handler imports
  - ✅ Dependency injection possible
  - ✅ Clear separation of concerns

  ---
  Total Impact Estimate

  If we complete all 3 phases:

  | Metric               | Before                    | After
             | Improvement    |
  |----------------------|---------------------------|------------
  -----------|----------------|
  | Duplicated code      | ~600 lines                | ~0 lines
             | 100%           |
  | Longest function     | 381 lines                 | ~80 lines
             | 79%            |
  | Functions >200 lines | 5 functions               | 0 functions
             | 100%           |
  | Handler complexity   | High (mixed concerns)     | Low (thin
  HTTP layer) | 70% reduction  |
  | Testability          | Poor (DB-dependent)       | Good
  (mockable)       | 5x improvement |
  | Maintainability      | Hard (duplication)        | Easy (DRY)
             | 3x improvement |
  | Bug risk             | High (3 places to update) | Low (1
  place)         | 67% reduction  |

  Time investment: 7-10 daysLong-term savings: Weeks of reduced
  maintenance, faster feature development

  ---
  Recommended Action Plan

  This Week:

  1. ✅ Extract get_today_schedule_entry() - Eliminates 150 lines
  of duplication
  2. ✅ Extract get_user_today() - Eliminates 16 lines across 8
  locations
  3. ✅ Extract is_test_prep_enabled() - Eliminates 27 lines
  4. ✅ Use existing get_words_reviewed_on_date() - Eliminates 20
  lines

  Quick win: ~210 lines eliminated in 2-3 days

  Next Week:

  5. ✅ Break down get_review_words_batch() into 5 functions
  6. ✅ Break down calc_schedule() into 4 functions
  7. ✅ Create config objects for long parameter lists

  Medium win: 600 lines → 15 focused functions

  Following Week:

  8. ✅ Create services layer for business logic
  9. ✅ Create repositories layer for data access
  10. ✅ Standardize database connection management

  Long-term win: Clean architecture, easy to test/maintain

  ---
  Bottom Line

  Your three core functions are extremely complex with massive
  duplication. The good news: most complexity comes from
  copy-pasted code that can be easily extracted into common
  functions.

  Biggest win: Extract the 150-line schedule calculation block
  that's duplicated 3 times. This single refactoring eliminates
  450 lines of code and makes all three functions 50% simpler.

  Ready to start? I recommend beginning with Phase 1 (extract
  common functions) - it's low-risk, high-impact, and can be done
  incrementally without breaking existing functionality.