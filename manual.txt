Completed Items âœ…

Language selection (57 languages)
Audio support for example sentences
Fibonacci/SuperMemo SM-2 algorithm implementation
Saved words sorting by due date
Review interval calculations
Settings page
Landing page
Screenshots

Bug Fixes ğŸ›

Fix audio loading issue in review mode
Fix review count discrepancy between list and detail views
Fix current_created_at undefined error in fix_next_review_dates
Fix retention rate calculation (should use date - last review/creation)
Fix forgetting curve graph (100% retention off by 1 day)
Include last review date at 100% on graph
Add creation date and next review date as markers

New Features ğŸ†•

Create /privacy-agreement page
Add AI illustration feature with OpenAI integration
Create illustration database table
Implement POST /generate-illustration and GET /illustration endpoints
Add leaderboard tab with user rankings by review count
Add user name and motto settings
Create stats with 4-step progress indicators
Add monthly review graph
Update progress icons (use brain.filled.head.profile with wiggle effect for final stage)

UI/UX Improvements ğŸ¨

Remove "word information" and "review statistics" sections from saved word detail page
Show next review date in saved words (to day precision, not seconds)
Show review count in saved words list
Use green gradient background for progress graph
Display datetime to seconds in detail stats

Future Marketing ğŸ“ˆ

TikTok ads campaign

----
1. we should use datetime everywhere in frontend and backend; only when we display it we change it to date;


when the backend returns forgetting_curve, it should include the last review at 100% and make a dotted line between last review and the next review date. the next review date marker should always be at 25% of retention;

1. on the retention curve, on x-axis we only show creation date, today and next review date;
1. rewrite CLAUDE.md to reflect current codebase; keep the principles; 
2. the line between the last review to next review should be dotted, now it is a full line; if dotted line is not supported we can use a grey color;
3. remove "historical" "projection" in the legends
4. remove "learning timeline"
5. the review history should show creation time 
6. the decay rate and the threshold to set the next review date should be configurable at compile time, make them constants at the top for easy tuning; 

2. refactor the frontend and backend code -- use multiple files, one for each class, improve the reusability of the code, give every class a meaningful name, remove unused code;
3. we should refactor integration test so all endpoints are properly tested
4. we should create unit tests too so business logic heavy functions are tested too


1. add a feedback section in the settings tab -- with a submit button; users can write what ever they want < 500 chars then submit it; we should have a table user_id, feedback, created_at to collect feedback;


2.
in review mode there is a "review complete" ReviewCompleteView, we should add a similar ReviewGoalAchievedView;
we should show ReviewGoalAchievedView when review overdue count reach 0 from 1 or more; 
it should show "reviews today" (reviews in the past 24 hours), success rate today (n the past 24 hours), 
changes from acquainted -> familiar, familiar -> remembered, remembered to unforgettable;
2 buttons: "Continue", "Review Stats"
 "Review Stats" should take users to saved words -> review stats;

 ReviewCompleteView right now only show up when there is no more words to review (all have been reviewed in the past 24h)
 keep this behaviour but change the stats to be the same as ReviewGoalAchievedView and there is only one button "Review Stats"


we should ask users to rate our app when he has > 100 reviews on the ReviewGoalAchievedView page; we should only trigger rating ask once ever; how can this be implemented? no code, discuss


1. create analytics system

for every user action, every button or tab click on the UI, we need to generate a user action
user_id, action enum, metadata


'action enum' should be save, lookup_search, lookup_search_audio, tab_leaderborad ,tab_review, review_yes, review_no, review_audio, username_update, usermotton_update, feedback_submit
basically category_action we can use   category_action_subaction if needed, plz design all the action enum

the /usage should show a table of counts by day by action in the past 7 days;

the /usage should show a table of all the actions for a user; a dropdown menu to select from all the users should be present


show me your plan, DDL sql and action enum


1. because users can be on any version of the app, everything we do must be backward compatible;

2. we should add a feature to show the users if the word they look up is not word. -- this will require a breaking ios change;
-- ios should call new version of the endpoint;
there must be a way to force an app upgrade

when users search a word, we should automatically save the word. show me how you would want to implement this. no code yet



1. we should allow people to remove saved words, add a new field in saved words 'removed', then every call must use removed filter;
2. or we can just really remove it from db and reivews, keep everything simple;

1. when we display word definitions in the contentview, if image loading should not stop new definition being rendered.
there is a problem when i search for a new word, it does not display definition, it reverted back to the landing view;
let's keep the logic simple: when a user search, or search a new word where there is already a definiton being displayed, or the user select to display a wrong word on the alert popup window. we IMEEDAITELY display the new word definitoin with no delay. 


1. ios app change: let's use ios/dogetionary/dogetionary/resources/logo.png as a logo to make a banner it should just be "<logo> Unforgettable Dictionary";
the banner should be on top of every page in the ios app

2. develop a feature on the definition on the frontend, we should let the user practice pronuncing the word or example sentences; 
the ui has a button to start recording, it sends back to backend; audio send to open ai to speech to text; the we ask open ai if the original and new audio recognized text are the similar enough; if yes, we report back to ui as success or no for failure; db should record user voice and results and time stamp; 
db should be id, original_text (could be just a word or an example sentence), user_audio, speech_to_text, result (boolean), created_at, metadata json


1. get rid of app

3. 404 is ok for submit_review
4. when unsave, we go back to list view
5. detail view when pronuciation is done

2. test 1.0.9 and 1.0.12(latest tag) frontend again


2. use /<learning_language>/<native_language>/<letter>/<word>
2.  
test_vocabularies -- the table we keep it simple, just word, langauge, is_toefl, is_ielts for now, we can alway extend
user_preferences -- we also just use toefl_enabled, ielts_enabled for easy extensibility;
get_daily_test_words -- if user enabled any test, we add 10 (make it configurable at compile tile, by dev not users), the 10 should be random, and not part of users already saved words;

1. remove unused code from UI and backend
2. restructure the backend and ui code so they are more manageable, improve reusability and readability, keep the code simple and stupid, no fancy stuff
3. reduce the amount of boilerplate code involving the database calls, use utility functions
4. Update README.md with current architecture and setup instructions
5. Add conprehensive integration tests, ensure all the tests are valid, do not skip tests
6. ensure each logs can be access from outsite and we keep about 2gb of logs available

1. disable toefl and iets

--- done ---


  1. HOW COMPONENTS INTERACT WITH EACH OTHER

  Architecture Pattern: Singleton-Heavy Service Layer

  The app uses a singleton-based architecture rather than traditional MVVM:

  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚         ContentView (Root)              â”‚
  â”‚  - Initializes 4 singleton managers     â”‚
  â”‚  - Controls tab navigation (int index)  â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â–¼             â–¼          â–¼         â–¼          â–¼
     SearchView   ScheduleView  ReviewView SavedWords Settings
          â”‚             â”‚          â”‚         â”‚          â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â–¼                           â–¼
    5 Singleton Managers        DictionaryService
    â”œâ”€â”€ UserManager              (30+ API methods)
    â”œâ”€â”€ QuestionQueueManager
    â”œâ”€â”€ NotificationManager
    â”œâ”€â”€ AnalyticsManager
    â””â”€â”€ AppVersionManager

  Data Flow Patterns

  1. Singleton Dependencies (Heavy Coupling)
  - Every major view depends on 3-5 singleton managers via @StateObject
  - Example from ContentView.swift:11-14:
  @StateObject private var userManager = UserManager.shared
  @StateObject private var notificationManager = NotificationManager.shared
  @StateObject private var questionQueue = QuestionQueueManager.shared
  @StateObject private var appVersionManager = AppVersionManager.shared

  2. UserManager as God Object
  - Manages 491 lines of responsibilities:
    - User identity (UUID generation)
    - Language preferences (learning/native)
    - Profile data (name, motto)
    - Test settings (TOEFL/IELTS/Tianz - legacy + V3 API)
    - Practice count caching
    - Onboarding state
    - Notification timing
    - Server sync on every property change (UserManager.swift:46-74)

  3. DictionaryService as API Gateway (1530 lines)
  - Single massive service with 30+ methods:
    - Word operations: search, save, unsave
    - Review system: submit, batch fetch, practice status
    - Audio: TTS generation, fetching
    - Illustrations: generate, fetch
    - User profile, leaderboard, achievements
    - Test progress, schedules
    - Feedback submission
  - Tight coupling: Calls UserManager.shared.getUserID() in every method
  (DictionaryService.swift:92)

  4. Communication Mechanisms

  NotificationCenter (6 notifications):
  .wordAutoSaved           â†’ DefinitionCard updates bookmark
  .wordUnsaved             â†’ SavedWordsView refreshes list
  .refreshSavedWords       â†’ SavedWordsView reloads
  .shouldNavigateToReview  â†’ ContentView switches to tab 2
  .performSearchFromOnboarding â†’ SearchView executes search
  .testSettingsChanged     â†’ QuestionQueueManager clears queue

  @Published Properties (Cascade Updates):
  UserManager.practiceCount
      â†“ triggers
  FloatingActionMenu badge update
      â†“ triggers
  ContentView re-render

  Completion Closures (everywhere):
  - DictionaryService uses callbacks for all async operations
  - No async/await consistency
  - Mix of Result<T, Error> and plain callbacks

  Question Queue System (Complex State Machine)

  QuestionQueueManager implements a sophisticated preload/refill pattern:

  App Launch
    â†“
  ContentView.onAppear (ContentView.swift:78)
    â†“
  questionQueue.preloadQuestions() â†’ fetches 3 questions
    â†“
    â””â†’ triggers refillIfNeeded() â†’ fetches 7 more (target: 10)

  ReviewView renders
    â†“
  currentQuestion() â†’ questionQueue.first (computed)
    â†“
  User swipes â†’ popQuestion()
    â†“
    â””â†’ removes from queue â†’ triggers refillIfNeeded()

  Issue: ReviewView recomputes currentQuestion on every render cycle instead
  of caching.

  ---
  2. WHAT CAN BE SIMPLIFIED FOR BETTER MANAGEABILITY

  CRITICAL SIMPLIFICATIONS

  A. Break Up God Objects

  DictionaryService (1530 lines) â†’ Split into:
  NetworkClient (shared infrastructure)
    â†“ Used by:
  â”œâ”€â”€ WordService (search, save, unsave)
  â”œâ”€â”€ ReviewService (submit answers, batch fetch)
  â”œâ”€â”€ AudioService (TTS, audio fetching)
  â”œâ”€â”€ IllustrationService (generate, fetch)
  â”œâ”€â”€ UserService (profile, preferences sync)
  â””â”€â”€ LeaderboardService (rankings, achievements)

  UserManager (491 lines) â†’ Extract:
  UserManager (identity only)
    â”œâ”€â”€ userID
    â”œâ”€â”€ getUserID()
    â””â”€â”€ (100 lines)

  PreferencesManager
    â”œâ”€â”€ languages
    â”œâ”€â”€ profile (name, motto)
    â”œâ”€â”€ syncToServer()
    â””â”€â”€ (150 lines)

  TestSettingsManager
    â”œâ”€â”€ activeTestType
    â”œâ”€â”€ targetDays
    â””â”€â”€ (100 lines)

  PracticeStatusManager
    â”œâ”€â”€ practiceCount
    â””â”€â”€ refreshPracticeStatus()

  ReviewView (1393 lines) â†’ Extract:
  ReviewView (coordinator)
    â”œâ”€â”€ QuestionCardView (presentation)
    â”œâ”€â”€ ReviewViewModel (state + logic)
    â”‚   â”œâ”€â”€ questionState
    â”‚   â”œâ”€â”€ answerState
    â”‚   â””â”€â”€ submitAnswer()
    â””â”€â”€ BadgeCelebrationView (already separate)

  B. Eliminate Singleton Overuse

  Current (ContentView.swift:11-14):
  @StateObject private var userManager = UserManager.shared
  @StateObject private var notificationManager = NotificationManager.shared
  @StateObject private var questionQueue = QuestionQueueManager.shared
  @StateObject private var appVersionManager = AppVersionManager.shared

  Simplified:
  // Use SwiftUI Environment for shared state
  @Environment(\.userManager) private var userManager
  @Environment(\.apiClient) private var apiClient

  // Or inject dependencies
  struct ReviewView {
      let questionQueue: QuestionQueueManager
      let reviewService: ReviewService
  }

  Benefits:
  - Testable (mock dependencies)
  - Clear dependencies (visible in initializer)
  - No hidden global state

  C. Consolidate Duplicate Patterns

  Pattern Found 5+ Times:
  func load<Something>Status() {
      isLoading = true
      DictionaryService.shared.get<Something> { result in
          DispatchQueue.main.async {
              self.isLoading = false
              switch result {
              case .success(let data):
                  self.<something> = data
              case .failure(let error):
                  print("Error: \(error)")
              }
          }
      }
  }

  Simplified with generic helper:
  extension View {
      func loadData<T>(
          _ loader: (@escaping (Result<T, Error>) -> Void) -> Void,
          into binding: Binding<T?>
      ) -> some View { ... }
  }

  // Usage:
  .task { await loadData(service.getPracticeStatus, into: $practiceStatus) }

  D. Remove NotificationCenter Dependency

  Current: 6 different notifications for inter-view communication

  Simplified:
  // Use @Environment for shared observable state
  @Observable class AppState {
      var practiceCount: Int = 0
      var savedWords: [SavedWord] = []
      var shouldShowReview: Bool = false
  }

  // In views:
  @Environment(AppState.self) var appState

  E. Centralize Audio Management

  Current: Audio loading duplicated in:
  - DefinitionCard (word + examples)
  - ReviewView
  - SearchView
  - Each maintains separate @State var audioData

  Simplified:
  @Observable class AudioCache {
      private var cache: [String: Data] = [:]

      func audio(for text: String, language: String) async -> Data? {
          if let cached = cache["\(text)-\(language)"] {
              return cached
          }
          let data = await audioService.fetch(text, language)
          cache["\(text)-\(language)"] = data
          return data
      }
  }

  F. Simplify Navigation

  Current: Integer-based tab selection
  @State private var selectedView = 0  // What's 0? What's 2?
  selectedView = 2  // Magic number

  Simplified:
  enum AppTab: Int, CaseIterable {
      case search = 0
      case schedule = 1
      case practice = 2
      case savedWords = 3
      case leaderboard = 4
      case settings = 5
  }

  @State private var selectedTab: AppTab = .search
  selectedTab = .practice  // Clear intent

  ---
  3. CODE QUALITY IMPROVEMENTS

  A. Architectural Issues

  1. Hidden Dependencies
  - Every view secretly depends on 5 singletons
  - No way to see dependencies from function signature
  - Impossible to test in isolation

  2. Violation of Single Responsibility
  - DictionaryService does 30+ different things
  - UserManager manages identity + preferences + test settings + practice
  cache
  - ReviewView handles questions + animations + audio + networking

  3. Tight Coupling
  - DictionaryService.swift:92 directly calls UserManager.shared.getUserID()
  - Views directly call DictionaryService.shared.searchWord()
  - Cannot swap implementations or mock for testing

  B. Error Handling Inconsistencies

  3 Different Patterns:

  1. Completion with Result (most common):
  completion: @escaping (Result<T, Error>) -> Void
  2. Async/await (UserManager.swift:107):
  func refreshPracticeStatus() async
  3. Silent failures (CompactIllustrationView.swift:501):
  case .failure(_):
      // Illustration doesn't exist yet, auto-generate it
      self.generateIllustration()

  Recommendation: Standardize on async/await with typed errors:
  enum ServiceError: Error {
      case networkError(URLError)
      case decodingError(DecodingError)
      case serverError(Int, String?)
      case notFound
  }

  C. Performance Issues

  1. Unnecessary Re-computation
  - ReviewView recomputes currentQuestion every render
  - Should cache and only update when queue changes

  2. Main Thread Blocking
  - Base64 encoding/decoding happens synchronously
  - ISO8601DateFormatter created in loops (SavedWordsView:63)

  3. Memory Concerns
  - No cache eviction policy for audio data
  - QuestionQueue can grow unbounded
  - Singleton managers never deallocate

  D. Magic Numbers Everywhere

  let swipeThreshold: CGFloat = 100  // QuestionCardView
  private let initialLoadCount = 3   // QuestionQueueManager
  private let targetQueueSize = 10
  .shadow(radius: 8, x: 0, y: 4)    // Repeated 20+ times
  .padding(.horizontal, 16)          // Inconsistent spacing

  Recommendation: Create constants file:
  enum AppConstants {
      enum Animation {
          static let defaultShadow = (radius: 8.0, x: 0.0, y: 4.0)
          static let swipeThreshold: CGFloat = 100
      }
      enum Layout {
          static let standardPadding: CGFloat = 16
          static let cardCornerRadius: CGFloat = 12
      }
      enum Queue {
          static let initialLoadCount = 3
          static let targetSize = 10
      }
  }

  E. Inconsistent Naming

  Swift side:
  var learningLanguage: String  // camelCase

  Model (from API):
  let learning_language: String  // snake_case

  Mixed:
  struct Definition {
      let word: String           // camelCase
      let learning_language: String  // snake_case
      let wordFamily: [WordFamilyEntry]  // camelCase
  }

  F. Missing Abstractions

  No NetworkRequest Protocol:
  // Instead of:
  performNetworkRequest(url: url, method: "POST", body: data, ...)

  // Could have:
  protocol NetworkRequest {
      associatedtype Response: Codable
      var endpoint: Endpoint { get }
      var method: HTTPMethod { get }
      var body: Encodable? { get }
  }

  // Usage:
  struct SaveWordRequest: NetworkRequest {
      typealias Response = SaveWordResponse
      let endpoint = .saveWord
      let method = .post
      let word: String
  }

  No typed endpoints:
  // Currently:
  guard let url = URL(string: "\(baseURL)/v3/save") else { ... }

  // Could be:
  enum Endpoint {
      case saveWord
      case searchWord(String)
      case nextReviewBatch(count: Int)

      var path: String { ... }
  }

  G. File Organization Chaos

  Current: 37 files in flat directory

  Issues:
  - Related files scattered
  - No clear module boundaries
  - Hard to navigate
  - Models file is 1293 lines with 50+ types

  Recommended Structure:
  dogetionary/
  â”œâ”€â”€ App/
  â”‚   â”œâ”€â”€ dogetionaryApp.swift
  â”‚   â””â”€â”€ ContentView.swift
  â”œâ”€â”€ Features/
  â”‚   â”œâ”€â”€ Search/
  â”‚   â”‚   â”œâ”€â”€ SearchView.swift
  â”‚   â”‚   â”œâ”€â”€ SearchViewModel.swift
  â”‚   â”‚   â””â”€â”€ Models/
  â”‚   â”‚       â””â”€â”€ SearchResult.swift
  â”‚   â”œâ”€â”€ Review/
  â”‚   â”‚   â”œâ”€â”€ Views/
  â”‚   â”‚   â”‚   â”œâ”€â”€ ReviewView.swift
  â”‚   â”‚   â”‚   â”œâ”€â”€ QuestionCardView.swift
  â”‚   â”‚   â”‚   â””â”€â”€ BadgeCelebrationView.swift
  â”‚   â”‚   â”œâ”€â”€ ViewModels/
  â”‚   â”‚   â”‚   â””â”€â”€ ReviewViewModel.swift
  â”‚   â”‚   â”œâ”€â”€ Models/
  â”‚   â”‚   â”‚   â””â”€â”€ ReviewQuestion.swift
  â”‚   â”‚   â””â”€â”€ Services/
  â”‚   â”‚       â”œâ”€â”€ QuestionQueueManager.swift
  â”‚   â”‚       â””â”€â”€ ReviewService.swift
  â”‚   â”œâ”€â”€ SavedWords/
  â”‚   â”œâ”€â”€ Schedule/
  â”‚   â”œâ”€â”€ Leaderboard/
  â”‚   â””â”€â”€ Settings/
  â”œâ”€â”€ Core/
  â”‚   â”œâ”€â”€ Networking/
  â”‚   â”‚   â”œâ”€â”€ NetworkClient.swift
  â”‚   â”‚   â”œâ”€â”€ Endpoint.swift
  â”‚   â”‚   â””â”€â”€ HTTPMethod.swift
  â”‚   â”œâ”€â”€ Models/
  â”‚   â”‚   â”œâ”€â”€ Definition.swift
  â”‚   â”‚   â”œâ”€â”€ SavedWord.swift
  â”‚   â”‚   â””â”€â”€ User.swift
  â”‚   â””â”€â”€ Services/
  â”‚       â”œâ”€â”€ AudioService.swift
  â”‚       â””â”€â”€ IllustrationService.swift
  â”œâ”€â”€ Shared/
  â”‚   â”œâ”€â”€ Components/
  â”‚   â”‚   â”œâ”€â”€ DefinitionCard.swift
  â”‚   â”‚   â””â”€â”€ FloatingActionMenu.swift
  â”‚   â”œâ”€â”€ Managers/
  â”‚   â”‚   â”œâ”€â”€ UserManager.swift
  â”‚   â”‚   â””â”€â”€ AnalyticsManager.swift
  â”‚   â””â”€â”€ Theme/
  â”‚       â”œâ”€â”€ AppTheme.swift
  â”‚       â””â”€â”€ AppConstants.swift
  â””â”€â”€ Utilities/
      â”œâ”€â”€ AudioPlayer.swift
      â””â”€â”€ Extensions/

  H. Specific Code Smells

  1. Completion Handler Pyramid
  DictionaryService.shared.searchWord(word) { result in
      DispatchQueue.main.async {
          switch result {
          case .success(let data):
              DictionaryService.shared.fetchAudio(word) { audioResult in
                  DispatchQueue.main.async {
                      // Nested callbacks...
                  }
              }
          }
      }
  }

  2. No [weak self] in closures
  - Risk of retain cycles with singleton managers
  - Example: QuestionQueueManager.swift:87 uses [weak self] but most places
  don't

  3. State machine not explicit
  - Review flow has implicit states (idle â†’ answering â†’ submitting â†’
  transitioning)
  - Should use enum:
  enum ReviewState {
      case idle
      case answering(question: BatchReviewQuestion)
      case submitting(answer: Answer)
      case transitioning
      case celebrating(Badge)
  }

  ---
  SUMMARY & PRIORITIZED RECOMMENDATIONS

  Critical (Do First)

  1. Split DictionaryService â†’ Domain-specific services (WordService,
  ReviewService, etc.)
  2. Extract ViewModels from heavy views (ReviewView, SearchView)
  3. Organize files into feature folders
  4. Replace NotificationCenter with Environment objects

  High Priority

  5. Centralize audio management â†’ AudioCache service
  6. Break up UserManager â†’ Separate identity, preferences, test settings
  7. Create constants file â†’ Remove magic numbers
  8. Standardize error handling â†’ Use async/await + typed errors

  Medium Priority

  9. Add typed endpoints â†’ NetworkRequest protocol
  10. Fix naming inconsistencies â†’ All camelCase
  11. Inject dependencies â†’ Remove singleton overuse
  12. Implement state machines â†’ Explicit review flow

  Long Term

  13. Add comprehensive tests (currently impossible due to singletons)
  14. Performance optimization â†’ Cache computed properties, background
  processing
  15. Modularize into Swift Packages â†’ Clear boundaries

  ---
  The codebase is functional but not maintainable. The biggest issue is
  excessive singleton usage creating hidden dependencies and tight coupling.
  This makes testing impossible and reasoning about code flow difficult. A
  phased refactoring focused on dependency injection and domain separation
  would dramatically improve code quality.






  Phase 1: Foundation (Low Risk)
  - Expand ThemeConstants.swift with spacing/corner radius/shadow scales
  - Add semantic theme layer (AppTheme.swift)
  - No UI changes yet

  Phase 2: Components (Medium Risk)
  - Create button component library
  - Create card/badge/input components
  - Migrate one view at a time to test

  Phase 3: Migration (High Risk)
  - Systematically replace inline styles with themed components
  - Start with OnboardingView (biggest win - 241 lines â†’ ~20)
  - Then ReviewView, ScheduleView, etc.

  Phase 4: Polish
  - Add color playground for experimentation
  - Document the design system